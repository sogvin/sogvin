<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<link rel="stylesheet" type="text/css" href="theme.css"/>
<link rel="stylesheet" type="text/css" href="a4.css"/>
<title>Strict mode - Software Engineering</title>
</head>
<body>
<header><code>Design - <a href="index.html">Software Engineering</a></code></header>
<article>
<h1>Strict mode</h1>
<p>Failing early is good for many reasons and strict mode design
       makes this very helpful during testing. An http client is a
       good place for this design.</p>
<h2>Client</h2>
<p>HTTP clients issue requests to some service, mainly by the Do
       method. Define the Strict interface to match that of the
       familiar testing T.Fatal.</p>
<pre class="srcfile"><code class="go">type Client struct {
	Strict
}

type Strict interface {
	Fatal(args ...interface{})
}

type StrictFunc func(...interface{})

func (s StrictFunc) Fatal(args ...interface{}) {
	s.Fatal(args...)
}
</code></pre><p>Once the client has the strict ability it can be used in it's
	  methods. Default the client to a lax mode where the Fatal method
	  does nothing.  </p>
<pre class="srcfile"><code class="go">func NewClient() *Client {
	return &Client{
		Strict: lax,
	}
}

var lax = StrictFunc(func(...interface{}) {})
</code></pre><p>Let's assume your service only accepts json and expects each
       request to set the correct header.  A simple wrapper around
       http.DefaultClient could look like this.  </p>
<div class="sidenote" style="margin-top: 1.2cm"><div class="inner">Use the strict wrapper in public methods.</div>
</div>
<div class="sidenote" style="margin-top: 5.7cm"><div class="inner">Private funcs just return errors as usual.</div>
</div>
<pre class="srcfile"><code class="go">func (c *Client) Do(r *http.Request) (*http.Response, error) {
	if err := c.checkContentType(r); err != nil {
		c.Fatal(err)
		return nil, err
	}
	resp, err := http.DefaultClient.Do(r)
	c.Fatal(err)
	return resp, err
}

func (c *Client) checkContentType(r *http.Request) error {
	got := r.Header.Get("Content-Type")
	exp := "application/json"
	if got != exp {
		return fmt.Errorf("checkContentType: %q must be %s", got, exp)
	}
	return nil
}
</code></pre><p>Any error from the sending of the request will be checked by
	  the strict interface. This adds no real benefit to the client
	  itself but it makes a difference when testing.</p>
<pre class="srcfile"><code class="go">func TestClient(t *testing.T) {
	c := NewClient()
	c.Strict = t
	r, _ := http.NewRequest("GET", "nothing", nil)
	c.Do(r)
}
</code></pre><pre class="command"><code>$ go test
--- FAIL: TestClient (0.00s)
    strictClient.go:32: checkContentType: "" must be application/json
</code></pre><p>Descriptive error messages make tests short and concise.  Use
	   <em>check</em> prefix to distinguish from asserts.</p>
</article>
<footer>Gregory Vin&ccaron;i&cacute;</footer></body>
</html>
