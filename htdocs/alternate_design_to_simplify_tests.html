<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<link rel="stylesheet" type="text/css" href="theme.css"/>
<link rel="stylesheet" type="text/css" href="a4.css"/>
<title>Alternate design to simplify tests - Software Engineering</title>

</head>
<body>
<header><code>Test - <a href="index.html">
Software Engineering
</a>
</code></header><article>
<h1>Alternate design to simplify tests</h1>
<p>Testing existing code you have several options to write sleek
		tests. Table driven or inlined test helpers work nicely. When
		writing new code however you have the option to choose a
		design that will be easier to verify. One go idiom is to
		return a value with an error. What if you didn't follow that
		idiom?
</p>
<ul>
<li>what if you always used panics?</li>
<li>what if you only returned a struct with an optional error field?</li>
</ul>
<p>Don't let the idiom stop you from experimenting. While
         working with inline helpers I found that functions, which
         only return errors, resulted in simpler and more readable
         tests. Two assert functions are needed, one for checking for
         an error and the other for nil errors. Remember that tests
         should focus on verifying logic, not data. In this case the
         logic is binary, failed or not.
</p>
<pre class="srcfile"><code class="go">func assertOk(t *testing.T) assertFunc {
	return func(err error, msg ...string) {
		t.Helper()
		if err != nil {
			if len(msg) > 0 {
				t.Error(strings.Join(msg, " ")+":", err)
				return
			}
			t.Error(err)
		}
	}
}

func assertBad(t *testing.T) assertFunc {
	return func(err error, msg ...string) {
		t.Helper()
		if err == nil {
			if len(msg) > 0 {
				t.Error(strings.Join(msg, " "), "should fail")
				return
			}
			t.Error("should fail")
		}
	}
}

func assert(t *testing.T) (ok, bad assertFunc) {
	return assertOk(t), assertBad(t)
}

type assertFunc func(error, ...string)
</code></pre><p>The initial design of the <a href="inline_test_helpers.html">
function double
</a>
follows the go idiom of returning a value with an error.
         Redesign the function to take the resulting argument and only
         return an error adds a few more lines to the function. We
         also added the check for nil result. The nil check may be
         left out or removed once you have your tests.  
</p>
<pre class="srcfile"><code class="go">// double sets the result to the double of i if i is positive but
// never more than max int
func double(result *int, i int) error {
	if result == nil {
		return fmt.Errorf("double: result cannot be nil")
	}
	if i < 0 {
		*result = 0
		return fmt.Errorf("double: i must be positive")
	}
	n := i * 2
	if n < i {
		*result = MAX
		return nil
	}
	*result = n
	return nil
}
</code></pre><p>Let's use our new assert functions.
</p>
<pre class="srcfile"><code class="go">func Test_double(t *testing.T) {
	var r int
	ok, _k := assert(t) // ok and Not ok, shortened to _k to achieve alignment
	ok(double(&r, 1))
	ok(double(&r, 3))
	ok(double(&r, MAX))
	_k(double(&r, -2))
	_k(double(nil, 2))

	// verify data, some is good
	check := func(i, exp int) {
		t.Helper()
		var got int
		double(&got, i)
		if got != exp {
			t.Errorf("got %v, exp %v", got, exp)
		}
	}
	check(0, 0)     // edge
	check(1, 2)     // ok
	check(MAX, MAX) // other edge
	check(-1, 0)    // bad
}
</code></pre>
</article><footer>Gregory Vin&ccaron;i&cacute;</footer>
</body>
</html>